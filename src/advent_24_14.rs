#![allow(clippy::unused_unit)]

// "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■", "■", "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "■"
// "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■"

use crate::*;

// https://adventofcode.com/2024/day/14
// 7853 / 6541


pub fn main_1() -> usize {  // 225552000
    let directions = map(
        |x| {
            let split = pstr::rstrip(&x).split(" ").collect::<Vec<_>>();
            vec![(*split[0]).to_string(), (*split[1]).to_string()]
        },
        open("day14/input.txt", "r").readlines(),
    ).collect::<Vec<Vec<_>>>();
    //let cols = 11;
    //let rows = 7;
    let cols = 101;
    let rows = 103;

    let mut positions = vec![(0, 0); len(&directions)];
    for (idx, direction) in enumerate(&directions) {  // zip
        let mut p = map(int::<i16>, direction[0].split("=").collect::<Vec<_>>()[1].split(",")).collect::<Vec<_>>();
        let v =     map(int::<i16>, direction[1].split("=").collect::<Vec<_>>()[1].split(",")).collect::<Vec<_>>();
        for _ in 0..100 {
            let mut incr = p[0] + v[0];
            while incr < 0 {
                incr += cols;
            }
            p[0] = incr % cols;

            incr = p[1] + v[1];
            while incr < 0 {
                incr += rows;
            }
            p[1] = incr % rows;
        }
        positions[idx] = (p[0], p[1]);
    }

    let mut count0 = 0;
    let mut count1 = 0;
    let mut count2 = 0;
    let mut count3 = 0;
    for pos in &positions {
        if pos.0 < cols / 2 && pos.1 < rows / 2 {
            count0 += 1;
        } else if pos.0 > cols / 2 && pos.1 < rows / 2 {
            count1 += 1;
        } else if pos.0 < cols / 2 && pos.1 > rows / 2 {
            count2 += 1;
        } else if pos.0 > cols / 2 && pos.1 > rows / 2 {
            count3 += 1;
        }
    }

    count0 * count1 * count2 * count3
}


pub fn main_2() {  // 7371
    let directions = map(
        |x| {
            let split = pstr::rstrip(&x).split(" ").collect::<Vec<_>>();
            vec![(*split[0]).to_string(), (*split[1]).to_string()]
        },
        open("day14/input.txt", "r").readlines(),
    ).collect::<Vec<Vec<_>>>();
    let cols = 101;
    let rows = 103;

    let mut positions = vec![(0, 0); len(&directions)];
    let mut vels = positions.clone();
    for (idx, direction) in enumerate(&directions) {
        let mut p = map(int::<i16>, direction[0].split("=").collect::<Vec<_>>()[1].split(",")).collect::<Vec<_>>();
        let v =     map(int::<i16>, direction[1].split("=").collect::<Vec<_>>()[1].split(",")).collect::<Vec<_>>();

        let mut incr = p[0] + v[0];
        while incr < 0 {
            incr += cols;
        }
        p[0] = incr % cols;

        incr = p[1] + v[1];
        while incr < 0 {
            incr += rows;
        }
        p[1] = incr % rows;
        positions[idx] = (p[0], p[1]);
        vels[idx] = (v[0], v[1]);
    }

    for count in 1..8000 {
        let mut field = vec![vec![" "; cols as usize]; rows as usize];
        for (idx, p) in enumerate(&positions.clone()) {
            let v = vels[idx];
            let mut incr = p.0 + v.0;
            while incr < 0 {
                incr += cols;
            }
            let p0 = incr % cols;

            incr = p.1 + v.1;
            while incr < 0 {
                incr += rows;
            }
            let p1 = incr % rows;
            positions[idx] = (p0, p1);
            field[p1 as usize][p0 as usize] = "■";
        }
        // TODO convolve with fitting kernel
        // or measure enhropy (gzip?)
        // or use the safety measure from part 1 (safest frame should indicate the answer)
        //for i in 0..rows {
        //    for j in 0..cols {
        //        if i != j && positions[i] == positions[j] {
        //            print(&count);
        //            return count;
        //        }
        //    }
        //}
        //" ", " ", " ", " ", " ", "■", " ", " ", " ", " ", " "
        //" ", " ", " ", " ", "■", "■", "■", " ", " ", " ", " "
        //" ", " ", " ", "■", "■", "■", "■", "■", " ", " ", " "
        //" ", " ", "■", "■", "■", "■", "■", "■", "■", " ", " "
        //" ", "■", "■", "■", "■", "■", "■", "■", "■", "■", " "
        //" ", " ", " ", "■", "■", "■", "■", "■", " ", " ", " "
        //" ", " ", "■", "■", "■", "■", "■", "■", "■", " ", " "
        //" ", "■", "■", "■", "■", "■", "■", "■", "■", "■", " "
        //"■", "■", "■", "■", "■", "■", "■", "■", "■", "■", "■"
        if count > 6000 {
            for _row in field {
                //println!("{row:?}");
            }
            //print(&count);
        }
    }
}
